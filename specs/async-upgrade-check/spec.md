# 功能规格说明书：异步升级检查

**Feature**: `async-upgrade-check`
**Scope**: `packages/commission-upgrade-bundle`
**创建日期**: 2025-11-19
**状态**: Draft
**输入**: 用户描述 "在判断用户升级时，考虑到性能问题,最好是用 symfony messenger 来丢异步执行的（实现 AsyncMessageInterface），也方便我们去复用逻辑"

## 用户场景与测试（必填）

<!--
  重要：用户故事按重要性排序，并保持“独立可测试”：
  - 只实现其中一个故事，也能形成可演示的 MVP
  - 每个故事可独立开发、测试、发布
  给每个故事标注优先级（P1/P2/P3）。
-->

### 用户故事 1 - 提现完成后异步触发升级检查（优先级：P1）

当分销员的提现流水状态变更为 Completed 时，系统应该将升级检查任务异步化处理，避免阻塞提现流程，确保提现操作能快速响应。

**优先级原因**：这是核心价值所在——解决同步升级检查阻塞提现流程的性能问题，直接影响用户体验和系统响应速度。

**独立验证方式**：创建一条提现流水并将其状态更新为 Completed，验证升级检查任务被正确投递到消息队列，且提现状态更新操作在 100ms 内完成（不等待升级检查结果）。

**验收场景**：

1. **Given** 分销员 A 当前等级为「初级分销员」，已有提现金额累计 4500 元，**When** 新增一笔 1000 元的提现流水并标记为 Completed，**Then** 系统在 100ms 内完成状态更新，并异步投递升级检查消息到队列
2. **Given** 消息队列中存在一条分销员升级检查消息，**When** 消费者处理该消息，**Then** 系统正确评估升级条件（withdrawnAmount >= 5000），并将分销员升级到「中级分销员」
3. **Given** 分销员 B 当前等级为「初级分销员」，已有提现金额累计 3000 元，**When** 新增一笔 500 元的提现流水并标记为 Completed，**Then** 系统投递升级检查消息，消费者处理后判定不满足升级条件，分销员等级保持不变

---

### 用户故事 2 - 升级检查任务可重试与幂等性（优先级：P1）

升级检查任务在消息队列中应该具备重试能力，且多次执行相同任务不会导致重复升级或数据不一致。

**优先级原因**：确保系统可靠性和数据一致性，防止因网络抖动、数据库临时故障等导致升级丢失或重复。

**独立验证方式**：模拟升级检查任务执行失败（如数据库临时不可用），验证任务能够重新入队并最终成功；验证同一分销员的相同升级检查任务多次执行后，只产生一条升级历史记录。

**验收场景**：

1. **Given** 升级检查消息已投递到队列，**When** 消费者首次处理时因数据库连接失败抛出异常，**Then** 消息重新入队并在后续重试中成功执行
2. **Given** 分销员 C 已满足升级条件且升级历史已记录，**When** 相同的升级检查消息再次被消费（重复投递或重试场景），**Then** 系统识别出分销员当前等级已升级，跳过重复升级，不产生新的升级历史记录
3. **Given** 升级检查消息连续失败 3 次（达到最大重试次数），**When** 消息进入死信队列，**Then** 系统记录错误日志并发送告警通知运营人员

---

### 用户故事 3 - 支持批量触发升级检查（优先级：P2）

管理员可以手动触发批量升级检查（例如规则变更后需要重新评估所有分销员），系统应该将每个分销员的升级检查任务异步化处理，避免长时间阻塞命令行或管理界面。

**优先级原因**：提升运营灵活性，支持规则调整后的批量重算场景，但不影响核心业务流程。

**独立验证方式**：通过命令行工具触发 1000 个分销员的升级检查，验证命令在 5 秒内返回（不等待所有检查完成），且所有升级检查任务被正确投递到队列并最终执行完成。

**验收场景**：

1. **Given** 系统中有 1000 个分销员，**When** 管理员执行批量升级检查命令，**Then** 命令在 5 秒内返回成功，1000 条升级检查消息被投递到队列
2. **Given** 升级检查消息队列中有 1000 条待处理消息，**When** 消费者以每秒 10 条的速度处理，**Then** 所有消息在 100 秒内处理完成，符合条件的分销员完成升级
3. **Given** 批量升级检查任务正在执行中，**When** 管理员再次触发相同批次的升级检查，**Then** 系统识别出重复请求并拒绝执行，返回友好提示信息

---

### 边界/异常场景

- **消息队列服务不可用**：当消息队列服务（如 RabbitMQ、Redis）不可用时，系统应该记录错误日志并降级到同步处理或失败快返，避免长时间阻塞主流程。
- **升级检查任务执行超时**：单个升级检查任务执行时间超过 30 秒视为超时，系统应该终止该任务并记录错误，允许重试机制介入。
- **并发升级冲突**：两个升级检查任务同时处理同一分销员时，系统应该通过乐观锁或分布式锁机制避免并发冲突，确保升级操作的原子性。
- **消息格式不兼容**：当消息队列中存在旧版本格式的升级检查消息时，消费者应该能够识别并兼容处理，或标记为不可处理并移入死信队列。

## 需求（必填）

### 功能需求

- **FR-001**：系统必须创建一个升级检查消息类（实现 `AsyncMessageInterface`），包含分销员唯一标识和可选的触发提现流水唯一标识
- **FR-002**：系统必须在提现流水状态变更为 Completed 时，异步投递升级检查消息到消息队列，而不是同步执行升级检查
- **FR-003**：系统必须提供升级检查消息的消费者，负责从消息队列中获取消息并执行升级检查逻辑
- **FR-004**：升级检查消息消费者必须复用现有的 `DistributorUpgradeService::checkAndUpgrade()` 方法，保持升级逻辑的一致性
- **FR-005**：系统必须确保升级检查任务的幂等性，同一分销员在相同条件下多次执行升级检查不会导致重复升级
- **FR-006**：系统必须支持升级检查任务的失败重试，最大重试次数为 3 次，失败后进入死信队列
- **FR-007**：系统必须记录升级检查任务的执行状态（投递、处理中、成功、失败），便于监控和排查问题
- **FR-008**：系统必须提供批量触发升级检查的命令行工具，支持按分销员 ID 范围或等级筛选
- **FR-009**：系统必须确保提现流水状态更新操作在 100ms 内完成（不等待升级检查结果），避免阻塞用户操作
- **FR-010**：系统必须在升级检查任务执行失败时记录详细错误日志，包含分销员 ID、失败原因、上下文快照等信息

### 核心实体（若涉及数据）

- **DistributorUpgradeCheckMessage**：升级检查异步消息，包含分销员唯一标识（distributorId）和可选的触发提现流水唯一标识（triggeringWithdrawLedgerId），实现 `AsyncMessageInterface` 接口
- **DistributorUpgradeCheckHandler**：升级检查消息处理器（消费者），负责从队列中获取消息并调用 `DistributorUpgradeService` 执行升级检查
- **DistributorUpgradeService**（已存在）：复用现有的升级检查核心服务，确保逻辑一致性

## 成功标准（必填）

### 可度量结果

- **SC-001**：提现流水状态更新为 Completed 时，系统在 100ms 内完成响应（不等待升级检查结果）
- **SC-002**：升级检查消息投递到队列的成功率 >= 99.9%（统计周期 7 天）
- **SC-003**：升级检查任务最终执行成功率 >= 99.5%（包含重试后成功的场景，统计周期 7 天）
- **SC-004**：单个升级检查任务的执行时间 <= 5 秒（P95 分位）
- **SC-005**：批量触发 1000 个分销员的升级检查命令在 5 秒内返回
- **SC-006**：同一分销员的升级检查任务在相同条件下多次执行后，只产生一条升级历史记录（幂等性验证通过率 100%）
- **SC-007**：升级检查任务失败后能够自动重试，重试成功率 >= 90%（统计周期 7 天）

### 可验证质量属性

- **性能**：异步化处理后，提现流程响应时间降低至少 80%（从原同步执行的 500ms 降至 100ms 以内）
- **可靠性**：消息队列支持持久化，系统重启后未处理的升级检查任务不会丢失
- **可观测性**：升级检查任务的投递、处理、成功、失败状态均有日志记录和监控指标，便于故障排查
- **兼容性**：异步化改造不影响现有的同步调用方式（如命令行工具直接调用 `DistributorUpgradeService`），保持向后兼容

## 范围与约束（必填）

### 包含范围

- 创建升级检查异步消息类（实现 `AsyncMessageInterface`）
- 创建升级检查消息处理器（消费者）
- 修改提现流水状态监听器，将同步升级检查改为异步投递消息
- 提供批量触发升级检查的命令行工具
- 添加升级检查任务的日志记录和监控指标

### 排除范围

- 不修改现有的 `DistributorUpgradeService` 核心升级逻辑
- 不涉及消息队列基础设施的搭建（假设项目已配置 Symfony Messenger）
- 不涉及升级规则的修改或优化
- 不提供升级检查任务的可视化管理界面（仅提供命令行工具和日志）

### 技术约束

- 必须使用 Symfony Messenger 组件作为消息队列抽象层
- 升级检查消息必须实现项目定义的 `AsyncMessageInterface` 接口
- 消息处理器必须遵循 Symfony Messenger 的 Handler 规范
- 不得破坏现有的事务边界和幂等性保障

### 业务约束

- 升级检查任务的延迟时间应控制在 10 秒以内（P95 分位，从投递到开始执行）
- 升级检查任务失败后的重试间隔采用指数退避策略（1秒、5秒、30秒）
- 死信队列中的失败任务需要运营人员手动介入处理，系统不自动重试

## 依赖与假设（必填）

### 依赖

- 依赖 `packages/async-contracts` 提供的 `AsyncMessageInterface` 接口定义
- 依赖项目已配置好的 Symfony Messenger 组件和消息队列传输层（RabbitMQ、Redis 等）
- 依赖 `DistributorUpgradeService` 提供的 `checkAndUpgrade()` 方法
- 依赖 Doctrine ORM 的乐观锁机制保障并发安全

### 假设

- 消息队列服务在正常情况下可用性 >= 99.9%
- 单个分销员的升级检查逻辑执行时间 <= 3 秒（基于现有实现的性能测试数据）
- 提现流水状态变更为 Completed 的频率 <= 100 次/秒（基于业务流量预估）
- 项目已有日志收集和监控告警基础设施（如 ELK、Prometheus）

## 非目标（可选）

- 不实现升级检查任务的优先级队列（所有任务按 FIFO 顺序处理）
- 不实现升级检查任务的实时进度查询接口
- 不优化现有的升级条件表达式评估性能（假设当前性能已满足需求）
- 不提供升级检查任务的手动取消功能
